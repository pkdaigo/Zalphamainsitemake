var at = Object.defineProperty;
var ot = (e, t, i) => t in e ? at(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var ge = (e, t, i) => ot(e, typeof t != "symbol" ? t + "" : t, i);
class Ce extends Error {
  constructor({ kind: i, description: r, error: o }) {
    super(JSON.stringify({ kind: i, description: r }));
    ge(this, "kind");
    ge(this, "description");
    ge(this, "error");
    this.kind = i, this.description = r, this.error = o;
  }
}
class st extends Ce {
  constructor(t, i) {
    super({
      kind: "ChatCreationFailed",
      description: `Failed to create ${i ? "persistent" : ""} chat, mode: ${t}`
    });
  }
}
class ct extends Ce {
  constructor(t) {
    super({ kind: "ChatModeDowngraded", description: `Chat mode downgraded to ${t}` });
  }
}
class fe extends Ce {
  constructor(i, r) {
    super({ kind: "ValidationError", description: i });
    ge(this, "key");
    this.key = r;
  }
}
class dt extends Ce {
  constructor(t) {
    super({ kind: "WSError", description: t });
  }
}
var ut = /* @__PURE__ */ ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(ut || {}), lt = /* @__PURE__ */ ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(lt || {}), ft = /* @__PURE__ */ ((e) => (e.Created = "created", e.Started = "started", e.Done = "done", e.Error = "error", e.Rejected = "rejected", e.Ready = "ready", e))(ft || {}), mt = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(mt || {}), x = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e.Off = "Off", e))(x || {}), X = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Transcribe = "transcribe", e.Complete = "done", e))(X || {}), gt = /* @__PURE__ */ ((e) => (e.KnowledgeProcessing = "knowledge/processing", e.KnowledgeIndexing = "knowledge/indexing", e.KnowledgeFailed = "knowledge/error", e.KnowledgeDone = "knowledge/done", e))(gt || {}), ht = /* @__PURE__ */ ((e) => (e.Knowledge = "knowledge", e.Document = "document", e.Record = "record", e))(ht || {}), pt = /* @__PURE__ */ ((e) => (e.Pdf = "pdf", e.Text = "text", e.Html = "html", e.Word = "word", e.Json = "json", e.Markdown = "markdown", e.Csv = "csv", e.Excel = "excel", e.Powerpoint = "powerpoint", e.Archive = "archive", e.Image = "image", e.Audio = "audio", e.Video = "video", e))(pt || {}), We = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e.Expressive = "expressive", e))(We || {});
const Dn = (e) => {
  switch (e) {
    case "clip":
      return "clip";
    case "talk":
      return "talk";
    case "expressive":
      return "expressive";
    default:
      throw new Error(`Unknown video type: ${e}`);
  }
};
var S = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(S || {}), ne = /* @__PURE__ */ ((e) => (e.Strong = "STRONG", e.Weak = "WEAK", e.Unknown = "UNKNOWN", e))(ne || {}), O = /* @__PURE__ */ ((e) => (e.Idle = "IDLE", e.Loading = "LOADING", e.Talking = "TALKING", e))(O || {}), A = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.ChatAudioTranscribed = "chat/audio-transcribed", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamInterrupt = "stream/interrupt", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(A || {}), T = /* @__PURE__ */ ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnecting = "disconnecting", e.Disconnected = "disconnected", e))(T || {}), re = /* @__PURE__ */ ((e) => (e.Legacy = "legacy", e.Fluent = "fluent", e))(re || {}), ke = /* @__PURE__ */ ((e) => (e.Livekit = "livekit", e))(ke || {}), wt = /* @__PURE__ */ ((e) => (e.Amazon = "amazon", e.AzureOpenAi = "azure-openai", e.Microsoft = "microsoft", e.Afflorithmics = "afflorithmics", e.Elevenlabs = "elevenlabs", e))(wt || {}), yt = /* @__PURE__ */ ((e) => (e.Public = "public", e.Premium = "premium", e.Private = "private", e))(yt || {});
const vt = 45 * 1e3, St = "X-Playground-Chat", pe = "https://api.d-id.com", Ct = "wss://notifications.d-id.com", kt = "79f81a83a67430be2bc0fd61042b8faa", Rt = (...e) => {
}, Oe = (e) => new Promise((t) => setTimeout(t, e)), me = (e = 16) => {
  const t = new Uint8Array(e);
  return window.crypto.getRandomValues(t), Array.from(t, (i) => i.toString(16).padStart(2, "0")).join("").slice(0, 13);
}, He = (e) => e.type === "clip" && e.presenter_id.startsWith("v2_") ? "clip_v2" : e.type, Ae = (e) => e === We.Expressive, Dt = (e) => [x.TextOnly, x.Playground, x.Maintenance].includes(e), qe = (e) => e && [x.DirectPlayback, x.Off].includes(e);
function Mt(e, t) {
  let i;
  return {
    promise: new Promise((o, a) => {
      i = setTimeout(() => a(new Error(t)), e);
    }),
    clear: () => clearTimeout(i)
  };
}
async function Me(e, t) {
  const i = {
    limit: (t == null ? void 0 : t.limit) ?? 3,
    delayMs: (t == null ? void 0 : t.delayMs) ?? 0,
    timeout: (t == null ? void 0 : t.timeout) ?? 3e4,
    timeoutErrorMessage: (t == null ? void 0 : t.timeoutErrorMessage) || "Timeout error",
    shouldRetryFn: (t == null ? void 0 : t.shouldRetryFn) ?? (() => !0),
    onRetry: (t == null ? void 0 : t.onRetry) ?? (() => {
    })
  };
  let r;
  for (let o = 1; o <= i.limit; o++)
    try {
      if (!i.timeout)
        return await e();
      const { promise: a, clear: s } = Mt(i.timeout, i.timeoutErrorMessage), d = e().finally(s);
      return await Promise.race([d, a]);
    } catch (a) {
      if (r = a, !i.shouldRetryFn(a) || o >= i.limit)
        throw a;
      await Oe(i.delayMs), i.onRetry(a);
    }
  throw r;
}
function Ee(e) {
  if (e !== void 0)
    return window.localStorage.setItem("did_external_key_id", e), e;
  let t = window.localStorage.getItem("did_external_key_id");
  if (!t) {
    let i = me();
    window.localStorage.setItem("did_external_key_id", i), t = i;
  }
  return t;
}
let Et = me();
function Qe(e, t) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${Ee(t)}_${Et}`;
  throw new Error(`Unknown auth type: ${e}`);
}
const It = (e) => Me(e, {
  limit: 3,
  delayMs: 1e3,
  timeout: 0,
  shouldRetryFn: (t) => t.status === 429
});
function Le(e, t = pe, i, r) {
  const o = async (a, s) => {
    const { skipErrorHandler: d, ...n } = s || {}, c = await It(
      () => fetch(t + (a != null && a.startsWith("/") ? a : `/${a}`), {
        ...n,
        headers: {
          ...n.headers,
          Authorization: Qe(e, r),
          "Content-Type": "application/json"
        }
      })
    );
    if (!c.ok) {
      let w = await c.text().catch(() => `Failed to fetch with status ${c.status}`);
      const y = new Error(w);
      throw i && !d && i(y, { url: a, options: n, headers: c.headers }), y;
    }
    return c.json();
  };
  return {
    get(a, s) {
      return o(a, { ...s, method: "GET" });
    },
    post(a, s, d) {
      return o(a, { ...d, body: JSON.stringify(s), method: "POST" });
    },
    delete(a, s, d) {
      return o(a, { ...d, body: JSON.stringify(s), method: "DELETE" });
    },
    patch(a, s, d) {
      return o(a, { ...d, body: JSON.stringify(s), method: "PATCH" });
    }
  };
}
function Tt(e, t = pe, i, r) {
  const o = Le(e, `${t}/agents`, i, r);
  return {
    create(a, s) {
      return o.post("/", a, s);
    },
    getAgents(a, s) {
      return o.get(`/${a ? `?tag=${a}` : ""}`, s).then((d) => d ?? []);
    },
    getById(a, s) {
      return o.get(`/${a}`, s);
    },
    delete(a, s) {
      return o.delete(`/${a}`, void 0, s);
    },
    update(a, s, d) {
      return o.patch(`/${a}`, s, d);
    },
    newChat(a, s, d) {
      return o.post(`/${a}/chat`, s, d);
    },
    chat(a, s, d, n) {
      return o.post(`/${a}/chat/${s}`, d, n);
    },
    createRating(a, s, d, n) {
      return o.post(`/${a}/chat/${s}/ratings`, d, n);
    },
    updateRating(a, s, d, n, c) {
      return o.patch(`/${a}/chat/${s}/ratings/${d}`, n, c);
    },
    deleteRating(a, s, d, n) {
      return o.delete(`/${a}/chat/${s}/ratings/${d}`, n);
    },
    getSTTToken(a, s) {
      return o.get(`/${a}/stt-token`, s);
    }
  };
}
function _t(e) {
  var o, a, s, d;
  const t = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", i = () => {
    const n = navigator.platform;
    return n.toLowerCase().includes("win") ? "Windows" : n.toLowerCase().includes("mac") ? "Mac OS X" : n.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, r = e.presenter;
  return {
    $os: `${i()}`,
    isMobile: `${t() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: He(r),
    agentVoice: {
      voiceId: (a = (o = e.presenter) == null ? void 0 : o.voice) == null ? void 0 : a.voice_id,
      provider: (d = (s = e.presenter) == null ? void 0 : s.voice) == null ? void 0 : d.type
    }
  };
}
function At(e) {
  var i, r, o, a, s, d;
  const t = (i = e.llm) == null ? void 0 : i.prompt_customization;
  return {
    agentType: He(e.presenter),
    owner_id: e.owner_id ?? "",
    promptVersion: (r = e.llm) == null ? void 0 : r.prompt_version,
    behavior: {
      role: t == null ? void 0 : t.role,
      personality: t == null ? void 0 : t.personality,
      instructions: (o = e.llm) == null ? void 0 : o.instructions
    },
    temperature: (a = e.llm) == null ? void 0 : a.temperature,
    knowledgeSource: t == null ? void 0 : t.knowledge_source,
    starterQuestionsCount: (d = (s = e.knowledge) == null ? void 0 : s.starter_message) == null ? void 0 : d.length,
    topicsToAvoid: t == null ? void 0 : t.topics_to_avoid,
    maxResponseLength: t == null ? void 0 : t.max_response_length,
    agentId: e.id,
    access: e.access,
    name: e.preview_name,
    ...e.access === "public" ? { from: "agent-template" } : {}
  };
}
const Lt = (e) => e.reduce((t, i) => t + i, 0), Fe = (e) => Lt(e) / e.length;
function Pt(e, t, i) {
  var n, c, w;
  const { event: r, ...o } = e, { template: a } = (t == null ? void 0 : t.llm) || {}, { language: s } = ((n = t == null ? void 0 : t.presenter) == null ? void 0 : n.voice) || {};
  return {
    ...o,
    llm: { ...o.llm, template: a },
    script: { ...o.script, provider: { ...(c = o == null ? void 0 : o.script) == null ? void 0 : c.provider, language: s } },
    stitch: (t == null ? void 0 : t.presenter.type) === "talk" ? (w = t == null ? void 0 : t.presenter) == null ? void 0 : w.stitch : void 0,
    ...i
  };
}
function ze(e) {
  "requestIdleCallback" in window ? requestIdleCallback(e, { timeout: 2e3 }) : setTimeout(e, 0);
}
let De = {};
const bt = "https://api-js.mixpanel.com/track/?verbose=1&ip=1";
function jt(e) {
  const t = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk";
  return {
    token: e.token || "testKey",
    distinct_id: Ee(e.externalId),
    agentId: e.agentId,
    additionalProperties: {
      id: Ee(e.externalId),
      ...e.mixpanelAdditionalProperties || {}
    },
    isEnabled: e.isEnabled ?? !0,
    getRandom: me,
    enrich(i) {
      this.additionalProperties = { ...this.additionalProperties, ...i };
    },
    async track(i, r, o) {
      if (!this.isEnabled)
        return Promise.resolve();
      const { audioPath: a, ...s } = r || {}, d = o || Date.now(), n = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([
            {
              event: i,
              properties: {
                ...this.additionalProperties,
                ...s,
                agentId: this.agentId,
                source: t,
                token: this.token,
                time: d,
                $insert_id: this.getRandom(),
                origin: window.location.href,
                "Screen Height": window.screen.height || window.innerWidth,
                "Screen Width": window.screen.width || window.innerHeight,
                "User Agent": navigator.userAgent
              }
            }
          ])
        })
      };
      return fetch(bt, {
        ...n,
        keepalive: !0
      }).catch((c) => console.error("Analytics tracking error:", c)), Promise.resolve();
    },
    linkTrack(i, r, o, a) {
      De[i] || (De[i] = { events: {}, resolvedDependencies: [] }), a.includes(o) || a.push(o);
      const s = De[i];
      if (s.events[o] = { props: r }, s.resolvedDependencies.push(o), a.every(
        (n) => s.resolvedDependencies.includes(n)
      )) {
        const n = a.reduce((c, w) => s.events[w] ? { ...c, ...s.events[w].props } : c, {});
        this.track(i, n), s.resolvedDependencies = s.resolvedDependencies.filter(
          (c) => !a.includes(c)
        ), a.forEach((c) => {
          delete s.events[c];
        });
      }
    }
  };
}
function Pe() {
  let e = 0;
  return {
    reset: () => e = 0,
    update: () => e = Date.now(),
    get: (t = !1) => t ? Date.now() - e : e
  };
}
const ee = Pe(), Ie = Pe(), Ke = Pe();
function Xe(e) {
  return e === x.Playground ? { headers: { [St]: "true" } } : {};
}
async function Ye(e, t, i, r, o = !1, a) {
  try {
    return !a && !qe(r) && (a = await t.newChat(e.id, { persist: o }, Xe(r)), i.track("agent-chat", {
      event: "created",
      chatId: a.id,
      mode: r
    })), { chat: a, chatMode: (a == null ? void 0 : a.chat_mode) ?? r };
  } catch (s) {
    throw $t(s) === "InsufficientCreditsError" ? new Error("InsufficientCreditsError") : new Error("Cannot create new chat");
  }
}
const $t = (e) => {
  try {
    const t = JSON.parse(e.message);
    return t == null ? void 0 : t.kind;
  } catch {
    return "UnknownError";
  }
};
function Bt(e) {
  return e && e.length > 0 ? e : [];
}
function xt(e, t, i, r) {
  const o = Le(e, `${t}/v2/agents/${i}`, r);
  return {
    async createStream(a) {
      return o.post("/sessions", a);
    }
  };
}
const Ge = (e, t) => (i, r) => e && console.log(`[${t}] ${i}`, r ?? "");
function Ft(e, t, i) {
  const r = (t.timestamp - e.timestamp) / 1e3;
  return {
    duration: r,
    bytesReceived: t.bytesReceived - e.bytesReceived,
    bitrate: Math.round((t.bytesReceived - e.bytesReceived) * 8 / r),
    packetsReceived: t.packetsReceived - e.packetsReceived,
    packetsLost: t.packetsLost - e.packetsLost,
    framesDropped: t.framesDropped - e.framesDropped,
    framesDecoded: t.framesDecoded - e.framesDecoded,
    jitter: t.jitter,
    avgJitterDelayInInterval: (t.jitterBufferDelay - e.jitterBufferDelay) / (t.jitterBufferEmittedCount - e.jitterBufferEmittedCount),
    jitterBufferEmittedCount: t.jitterBufferEmittedCount - e.jitterBufferEmittedCount,
    jitterBufferDelay: (t.jitterBufferDelay - e.jitterBufferDelay) / r,
    framesPerSecond: t.framesPerSecond,
    freezeCount: t.freezeCount - e.freezeCount,
    freezeDuration: t.freezeDuration - e.freezeDuration,
    lowFpsCount: i
  };
}
function zt(e) {
  return e.filter(
    (t) => t.freezeCount > 0 || t.framesPerSecond < 21 || t.framesDropped > 0 || t.packetsLost > 0
  ).map((t) => {
    const { timestamp: i, ...r } = t, o = [];
    return t.freezeCount > 0 && o.push("freeze"), t.framesPerSecond < 21 && o.push("low fps"), t.framesDropped > 0 && o.push("frames dropped"), t.packetsLost > 0 && o.push("packet loss"), {
      ...r,
      causes: o
    };
  });
}
function Kt(e) {
  let t = "", i = 0;
  for (const r of e.values()) {
    if (r && r.type === "codec" && r.mimeType.startsWith("video") && (t = r.mimeType.split("/")[1]), r && r.type === "candidate-pair") {
      const o = r.currentRoundTripTime, s = r.nominated === !0;
      o > 0 && (s || i === 0) && (i = o);
    }
    if (r && r.type === "inbound-rtp" && r.kind === "video")
      return {
        codec: t,
        rtt: i,
        timestamp: r.timestamp,
        bytesReceived: r.bytesReceived,
        packetsReceived: r.packetsReceived,
        packetsLost: r.packetsLost,
        framesDropped: r.framesDropped,
        framesDecoded: r.framesDecoded,
        jitter: r.jitter,
        jitterBufferDelay: r.jitterBufferDelay,
        jitterBufferEmittedCount: r.jitterBufferEmittedCount,
        avgJitterDelayInInterval: r.jitterBufferDelay / r.jitterBufferEmittedCount,
        frameWidth: r.frameWidth,
        frameHeight: r.frameHeight,
        framesPerSecond: r.framesPerSecond,
        freezeCount: r.freezeCount,
        freezeDuration: r.totalFreezesDuration
      };
  }
  return {};
}
function Ne(e, t, i) {
  const r = e.map((n, c) => c === 0 ? i ? {
    timestamp: n.timestamp,
    duration: 0,
    rtt: n.rtt,
    bytesReceived: n.bytesReceived - i.bytesReceived,
    bitrate: (n.bytesReceived - i.bytesReceived) * 8 / (t / 1e3),
    packetsReceived: n.packetsReceived - i.packetsReceived,
    packetsLost: n.packetsLost - i.packetsLost,
    framesDropped: n.framesDropped - i.framesDropped,
    framesDecoded: n.framesDecoded - i.framesDecoded,
    jitter: n.jitter,
    jitterBufferDelay: n.jitterBufferDelay - i.jitterBufferDelay,
    jitterBufferEmittedCount: n.jitterBufferEmittedCount - i.jitterBufferEmittedCount,
    avgJitterDelayInInterval: (n.jitterBufferDelay - i.jitterBufferDelay) / (n.jitterBufferEmittedCount - i.jitterBufferEmittedCount),
    framesPerSecond: n.framesPerSecond,
    freezeCount: n.freezeCount - i.freezeCount,
    freezeDuration: n.freezeDuration - i.freezeDuration
  } : {
    timestamp: n.timestamp,
    rtt: n.rtt,
    duration: 0,
    bytesReceived: n.bytesReceived,
    bitrate: n.bytesReceived * 8 / (t / 1e3),
    packetsReceived: n.packetsReceived,
    packetsLost: n.packetsLost,
    framesDropped: n.framesDropped,
    framesDecoded: n.framesDecoded,
    jitter: n.jitter,
    jitterBufferDelay: n.jitterBufferDelay,
    jitterBufferEmittedCount: n.jitterBufferEmittedCount,
    avgJitterDelayInInterval: n.jitterBufferDelay / n.jitterBufferEmittedCount,
    framesPerSecond: n.framesPerSecond,
    freezeCount: n.freezeCount,
    freezeDuration: n.freezeDuration
  } : {
    timestamp: n.timestamp,
    duration: t * c / 1e3,
    rtt: n.rtt,
    bytesReceived: n.bytesReceived - e[c - 1].bytesReceived,
    bitrate: (n.bytesReceived - e[c - 1].bytesReceived) * 8 / (t / 1e3),
    packetsReceived: n.packetsReceived - e[c - 1].packetsReceived,
    packetsLost: n.packetsLost - e[c - 1].packetsLost,
    framesDropped: n.framesDropped - e[c - 1].framesDropped,
    framesDecoded: n.framesDecoded - e[c - 1].framesDecoded,
    jitter: n.jitter,
    jitterBufferDelay: n.jitterBufferDelay - e[c - 1].jitterBufferDelay,
    jitterBufferEmittedCount: n.jitterBufferEmittedCount - e[c - 1].jitterBufferEmittedCount,
    avgJitterDelayInInterval: (n.jitterBufferDelay - e[c - 1].jitterBufferDelay) / (n.jitterBufferEmittedCount - e[c - 1].jitterBufferEmittedCount),
    framesPerSecond: n.framesPerSecond,
    freezeCount: n.freezeCount - e[c - 1].freezeCount,
    freezeDuration: n.freezeDuration - e[c - 1].freezeDuration
  }), o = zt(r), a = o.reduce((n, c) => n + (c.causes.includes("low fps") ? 1 : 0), 0), s = r.filter((n) => !!n.avgJitterDelayInInterval).map((n) => n.avgJitterDelayInInterval), d = r.filter((n) => !!n.rtt).map((n) => n.rtt);
  return {
    webRTCStats: {
      anomalies: o,
      minRtt: Math.min(...d),
      avgRtt: Fe(d),
      maxRtt: Math.max(...d),
      aggregateReport: Ft(e[0], e[e.length - 1], a),
      minJitterDelayInInterval: Math.min(...s),
      maxJitterDelayInInterval: Math.max(...s),
      avgJitterDelayInInterval: Fe(s)
    },
    codec: e[0].codec,
    resolution: `${e[0].frameWidth}x${e[0].frameHeight}`
  };
}
const Se = 100, Nt = Math.max(Math.ceil(400 / Se), 1), Vt = 0.25, Jt = 0.28;
function Ut() {
  let e = 0, t, i, r = 0;
  return (o) => {
    for (const a of o.values())
      if (a && a.type === "inbound-rtp" && a.kind === "video") {
        const s = a.jitterBufferDelay, d = a.jitterBufferEmittedCount;
        if (i && d > i) {
          const w = s - t, y = d - i;
          r = w / y;
        }
        t = s, i = d;
        const n = a.framesDecoded, c = n - e > 0;
        return e = n, { isReceiving: c, avgJitterDelayInInterval: r, freezeCount: a.freezeCount };
      }
    return { isReceiving: !1, avgJitterDelayInInterval: r };
  };
}
function Ze(e, t, i, r, o) {
  let a = null, s = [], d, n = 0, c = !1, w = ne.Unknown, y = ne.Unknown, g = 0, f = 0;
  const L = Ut();
  async function J() {
    const D = await e();
    if (!D)
      return;
    const { isReceiving: k, avgJitterDelayInInterval: P, freezeCount: I } = L(D), F = Kt(D);
    if (k)
      n = 0, g = I - f, y = P < Vt ? ne.Strong : P > Jt && g > 1 ? ne.Weak : w, y !== w && (o == null || o(y), w = y, f += g, g = 0), c || (r == null || r(S.Start), d = s[s.length - 1], s = [], c = !0), s.push(F);
    else if (c && (n++, n >= Nt)) {
      const $ = Ne(s, Se, d);
      r == null || r(S.Stop, $), t() || i(), f = I, c = !1;
    }
  }
  return {
    start: () => {
      a || (a = setInterval(J, Se));
    },
    stop: () => {
      a && (clearInterval(a), a = null);
    },
    getReport: () => Ne(s, Se, d)
  };
}
async function Wt() {
  try {
    return await import("./livekit-client.esm-C1GRQdZY.js");
  } catch {
    throw new Error(
      "LiveKit client is required for this streaming manager. Please install it using: npm install livekit-client"
    );
  }
}
const Ot = {
  excellent: ne.Strong,
  good: ne.Strong,
  poor: ne.Weak,
  lost: ne.Unknown,
  unknown: ne.Unknown
}, he = JSON.stringify({
  kind: "InternalServerError",
  description: "Stream Error"
});
var be = /* @__PURE__ */ ((e) => (e.Chat = "lk.chat", e.Speak = "did.speak", e.Interrupt = "did.interrupt", e))(be || {});
function Te(e, t, i) {
  var r, o;
  throw t("Failed to connect to LiveKit room:", e), (r = i.onConnectionStateChange) == null || r.call(i, T.Fail, "internal:init-error"), (o = i.onError) == null || o.call(i, e, { sessionId: "" }), e;
}
async function Ht(e, t, i) {
  var je;
  const r = Ge(i.debug || !1, "LiveKitStreamingManager"), { Room: o, RoomEvent: a, ConnectionState: s, Track: d } = await Wt(), { callbacks: n, auth: c, baseURL: w, analytics: y, microphoneStream: g } = i;
  let f = null, L = !1;
  const J = re.Fluent;
  let D = null, k = null, P = null, I = null, F = !1;
  f = new o({
    adaptiveStream: !1,
    // Must be false to use mediaStreamTrack directly
    dynacast: !0
  });
  let $ = null;
  const H = 2e4;
  let Z = O.Idle;
  const se = xt(c, w || pe, e, n.onError);
  let N, u, C;
  try {
    const l = await se.createStream({
      transport_provider: ke.Livekit,
      chat_persist: t.chat_persist ?? !0
    }), { id: h, session_token: v, session_url: E } = l;
    (je = n.onStreamCreated) == null || je.call(n, { session_id: h, stream_id: h, agent_id: e }), N = h, u = v, C = E, await f.prepareConnection(C, u);
  } catch (l) {
    Te(l, r, n);
  }
  if (!C || !u || !N)
    return Promise.reject(new Error("Failed to initialize LiveKit stream"));
  f.on(a.ConnectionStateChanged, z).on(a.ConnectionQualityChanged, b).on(a.ParticipantConnected, _).on(a.ParticipantDisconnected, K).on(a.TrackSubscribed, j).on(a.TrackUnsubscribed, B).on(a.DataReceived, Y).on(a.MediaDevicesError, ie).on(a.TranscriptionReceived, R).on(a.EncryptionError, p).on(a.TrackSubscriptionFailed, m);
  function R(l, h) {
    var v;
    h != null && h.isLocal && (ee.update(), Z === O.Talking && ((v = n.onInterruptDetected) == null || v.call(n, { type: "audio" }), Z = O.Idle));
  }
  try {
    await f.connect(C, u), r("LiveKit room joined successfully"), $ = setTimeout(() => {
      var l;
      r("Track subscription timeout - no track subscribed within 30 seconds after connect"), $ = null, y.track("connectivity-error", {
        error: "Track subscription timeout",
        sessionId: N
      }), (l = n.onError) == null || l.call(n, new Error("Track subscription timeout"), { sessionId: N }), Re("internal:track-subscription-timeout");
    }, H);
  } catch (l) {
    Te(l, r, n);
  }
  y.enrich({
    "stream-type": J
  });
  function z(l) {
    var h, v, E, U;
    switch (r("Connection state changed:", l), l) {
      case s.Connecting:
        r("CALLBACK: onConnectionStateChange(Connecting)"), (h = n.onConnectionStateChange) == null || h.call(n, T.Connecting, "livekit:connecting");
        break;
      case s.Connected:
        r("LiveKit room connected successfully"), L = !0;
        break;
      case s.Disconnected:
        r("LiveKit room disconnected"), L = !1, F = !1, (v = n.onConnectionStateChange) == null || v.call(n, T.Disconnected, "livekit:disconnected");
        break;
      case s.Reconnecting:
        r("LiveKit room reconnecting..."), (E = n.onConnectionStateChange) == null || E.call(n, T.Connecting, "livekit:reconnecting");
        break;
      case s.SignalReconnecting:
        r("LiveKit room signal reconnecting..."), (U = n.onConnectionStateChange) == null || U.call(n, T.Connecting, "livekit:signal-reconnecting");
        break;
    }
  }
  function b(l, h) {
    var v;
    r("Connection quality:", l), h != null && h.isLocal && ((v = n.onConnectivityStateChange) == null || v.call(n, Ot[l]));
  }
  function _(l) {
    r("Participant connected:", l.identity);
  }
  function K(l) {
    r("Participant disconnected:", l.identity), Re("livekit:participant-disconnected");
  }
  function q() {
    var l;
    I !== S.Start && (r("CALLBACK: onVideoStateChange(Start)"), I = S.Start, (l = n.onVideoStateChange) == null || l.call(n, S.Start));
  }
  function W(l) {
    var h;
    I !== S.Stop && (r("CALLBACK: onVideoStateChange(Stop)"), I = S.Stop, (h = n.onVideoStateChange) == null || h.call(n, S.Stop, l));
  }
  function j(l, h, v) {
    var U, V, ae;
    r(`Track subscribed: ${l.kind} from ${v.identity}`), $ && (clearTimeout($), $ = null, r("Track subscription timeout cleared"));
    const E = l.mediaStreamTrack;
    if (!E) {
      r(`No mediaStreamTrack available for ${l.kind}`);
      return;
    }
    D ? (D.addTrack(E), r(`Added ${l.kind} track to shared MediaStream`)) : (D = new MediaStream([E]), r(`Created shared MediaStream with ${l.kind} track`)), l.kind === "video" && ((U = n.onStreamReady) == null || U.call(n), r("CALLBACK: onSrcObjectReady"), (V = n.onSrcObjectReady) == null || V.call(n, D), F || (F = !0, r("CALLBACK: onConnectionStateChange(Connected)"), (ae = n.onConnectionStateChange) == null || ae.call(n, T.Connected, "livekit:track-subscribed")), P = Ze(
      () => l.getRTCStatsReport(),
      () => L,
      Rt,
      (le, ye) => {
        r(`Video state change: ${le}`), le === S.Start ? q() : le === S.Stop && W(ye);
      }
    ), P.start());
  }
  function B(l, h, v) {
    r(`Track unsubscribed: ${l.kind} from ${v.identity}`), l.kind === "video" && (W(P == null ? void 0 : P.getReport()), P == null || P.stop(), P = null);
  }
  function Y(l, h, v, E) {
    var V, ae, le, ye, $e, Be;
    const U = new TextDecoder().decode(l);
    try {
      const Q = JSON.parse(U), oe = E || Q.subject;
      if (r("Data received:", { subject: oe, data: Q }), oe === A.ChatAnswer) {
        const te = X.Answer;
        (V = n.onMessage) == null || V.call(n, te, {
          event: te,
          ...Q
        });
      } else if (oe === A.ChatPartial) {
        const te = X.Partial;
        (ae = n.onMessage) == null || ae.call(n, te, {
          event: te,
          ...Q
        });
      } else if ([
        A.StreamVideoCreated,
        A.StreamVideoDone,
        A.StreamVideoError,
        A.StreamVideoRejected
      ].includes(oe)) {
        Z = oe === A.StreamVideoCreated ? O.Talking : O.Idle, (le = n.onAgentActivityStateChange) == null || le.call(n, Z);
        const { role: te, status: ve, ...nt } = Q, rt = te ?? (h == null ? void 0 : h.identity) ?? "datachannel", it = ve ?? oe.split("/").pop() ?? "unknown", xe = { [rt]: { ...nt, status: it } };
        i.debug && ((ye = Q == null ? void 0 : Q.metadata) != null && ye.sentiment) && (xe.sentiment = {
          id: Q.metadata.sentiment.id,
          name: Q.metadata.sentiment.sentiment
        }), ($e = n.onMessage) == null || $e.call(n, oe, xe);
      } else if (oe === A.ChatAudioTranscribed) {
        const te = X.Transcribe;
        (Be = n.onMessage) == null || Be.call(n, te, {
          event: te,
          ...Q
        }), queueMicrotask(() => {
          var ve;
          (ve = n.onAgentActivityStateChange) == null || ve.call(n, O.Loading);
        });
      }
    } catch (Q) {
      r("Failed to parse data channel message:", Q);
    }
  }
  function ie(l) {
    var h;
    r("Media devices error:", l), (h = n.onError) == null || h.call(n, new Error(he), { sessionId: N });
  }
  function p(l) {
    var h;
    r("Encryption error:", l), (h = n.onError) == null || h.call(n, new Error(he), { sessionId: N });
  }
  function m(l, h, v) {
    r("Track subscription failed:", { trackSid: l, participant: h, reason: v });
  }
  function M(l) {
    if (!f) return null;
    const h = f.localParticipant.audioTrackPublications;
    if (h) {
      for (const [v, E] of h)
        if (E.source === d.Source.Microphone && E.track) {
          const V = E.track.mediaStreamTrack;
          if (V === l || V && V.id === l.id)
            return E;
        }
    }
    return null;
  }
  function G(l) {
    if (!k || !k.track)
      return !1;
    const h = k.track.mediaStreamTrack;
    return h !== l && (h == null ? void 0 : h.id) !== l.id;
  }
  async function ce(l) {
    var U, V;
    if (!L || !f)
      throw r("Room is not connected, cannot publish microphone stream"), new Error("Room is not connected");
    const h = l.getAudioTracks();
    if (h.length === 0) {
      r("No audio track found in the provided MediaStream");
      return;
    }
    const v = h[0], E = M(v);
    if (E) {
      r("Microphone track is already published, skipping", {
        trackId: v.id,
        publishedTrackId: (V = (U = E.track) == null ? void 0 : U.mediaStreamTrack) == null ? void 0 : V.id
      }), k = E;
      return;
    }
    G(v) && (r("Unpublishing existing microphone track before publishing new one"), await de()), r("Publishing microphone track from provided MediaStream", { trackId: v.id });
    try {
      k = await f.localParticipant.publishTrack(v, {
        source: d.Source.Microphone
      }), r("Microphone track published successfully", { trackSid: k.trackSid });
    } catch (ae) {
      throw r("Failed to publish microphone track:", ae), ae;
    }
  }
  async function de() {
    if (!(!k || !k.track))
      try {
        f && (await f.localParticipant.unpublishTrack(k.track), r("Microphone track unpublished"));
      } catch (l) {
        r("Error unpublishing microphone track:", l);
      } finally {
        k = null;
      }
  }
  function we() {
    D && (D.getTracks().forEach((l) => l.stop()), D = null);
  }
  async function ue(l, h) {
    var v, E;
    if (!L || !f) {
      r("Room is not connected for sending messages"), (v = n.onError) == null || v.call(n, new Error(he), {
        sessionId: N
      });
      return;
    }
    try {
      await f.localParticipant.sendText(l, { topic: h }), r("Message sent successfully:", l);
    } catch (U) {
      r("Failed to send message:", U), (E = n.onError) == null || E.call(n, new Error(he), { sessionId: N });
    }
  }
  async function et(l) {
    var h;
    try {
      const E = JSON.parse(l).topic;
      return ue("", E);
    } catch (v) {
      r("Failed to send data channel message:", v), (h = n.onError) == null || h.call(n, new Error(he), { sessionId: N });
    }
  }
  function tt(l) {
    return ue(
      l,
      "lk.chat"
      /* Chat */
    );
  }
  async function Re(l) {
    var h, v;
    $ && (clearTimeout($), $ = null), f && (await de(), (h = n.onConnectionStateChange) == null || h.call(n, T.Disconnecting, l), await f.disconnect()), we(), L = !1, F = !1, (v = n.onAgentActivityStateChange) == null || v.call(n, O.Idle), Z = O.Idle;
  }
  return {
    speak(l) {
      const h = typeof l == "string" ? l : JSON.stringify(l);
      return ue(
        h,
        "did.speak"
        /* Speak */
      );
    },
    disconnect: () => Re("user:disconnect"),
    async reconnect() {
      var l, h;
      if ((f == null ? void 0 : f.state) === s.Connected) {
        r("Room is already connected");
        return;
      }
      if (!f || !C || !u)
        throw r("Cannot reconnect: missing room, URL or token"), new Error("Cannot reconnect: session not available");
      r("Reconnecting to LiveKit room, state:", f.state), F = !1, (l = n.onConnectionStateChange) == null || l.call(n, T.Connecting, "user:reconnect");
      try {
        if (await f.connect(C, u), r("Room reconnected"), L = !0, f.remoteParticipants.size === 0) {
          if (r("Waiting for agent to join..."), !await new Promise((E) => {
            const U = setTimeout(() => {
              f == null || f.off(a.ParticipantConnected, V), E(!1);
            }, 5e3), V = () => {
              clearTimeout(U), f == null || f.off(a.ParticipantConnected, V), E(!0);
            };
            f == null || f.on(a.ParticipantConnected, V);
          }))
            throw r("Agent did not join within timeout"), await f.disconnect(), new Error("Agent did not rejoin the room");
          r("Agent joined, reconnection successful");
        }
      } catch (v) {
        throw r("Failed to reconnect:", v), (h = n.onConnectionStateChange) == null || h.call(n, T.Fail, "user:reconnect-failed"), v;
      }
    },
    sendDataChannelMessage: et,
    sendTextMessage: tt,
    publishMicrophoneStream: ce,
    unpublishMicrophoneStream: de,
    sessionId: N,
    streamId: N,
    streamType: J,
    interruptAvailable: !0,
    triggersAvailable: !1
  };
}
const qt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataChannelTopic: be,
  createLiveKitStreamingManager: Ht,
  handleInitError: Te
}, Symbol.toStringTag, { value: "Module" }));
function Qt(e, t, i) {
  if (!e)
    throw new Error("Please connect to the agent first");
  if (!e.interruptAvailable)
    throw new Error("Interrupt is not enabled for this stream");
  if (t !== re.Fluent)
    throw new Error("Interrupt only available for Fluent streams");
  if (!i)
    throw new Error("No active video to interrupt");
}
async function Xt(e, t) {
  const i = {
    type: A.StreamInterrupt,
    videoId: t,
    timestamp: Date.now()
  };
  e.sendDataChannelMessage(JSON.stringify(i));
}
async function Yt(e) {
  const t = {
    topic: be.Interrupt
  };
  e.sendDataChannelMessage(JSON.stringify(t));
}
function Gt(e) {
  return new Promise((t, i) => {
    const { callbacks: r, host: o, auth: a, externalId: s } = e, { onMessage: d = null, onOpen: n = null, onClose: c = null, onError: w = null } = r || {}, y = new WebSocket(`${o}?authorization=${encodeURIComponent(Qe(a, s))}`);
    y.onmessage = d, y.onclose = c, y.onerror = (g) => {
      console.error(g), w == null || w("Websocket failed to connect", g), i(g);
    }, y.onopen = (g) => {
      n == null || n(g), t(y);
    };
  });
}
async function Zt(e) {
  const { retries: t = 1 } = e;
  let i = null;
  for (let r = 0; (i == null ? void 0 : i.readyState) !== WebSocket.OPEN; r++)
    try {
      i = await Gt(e);
    } catch (o) {
      if (r === t)
        throw o;
      await Oe(r * 500);
    }
  return i;
}
async function en(e, t, i, r) {
  const o = i != null && i.onMessage ? [i.onMessage] : [], a = await Zt({
    auth: e,
    host: t,
    externalId: r,
    callbacks: {
      onError: (s) => {
        var d;
        return (d = i.onError) == null ? void 0 : d.call(i, new dt(s));
      },
      onMessage(s) {
        const d = JSON.parse(s.data);
        o.forEach((n) => n(d.event, d));
      }
    }
  });
  return {
    socket: a,
    disconnect: () => a.close(),
    subscribeToEvents: (s) => o.push(s)
  };
}
function tn(e) {
  if (e.answer !== void 0)
    return e.answer;
  let t = 0, i = "";
  for (; t in e; )
    i += e[t++];
  return i;
}
function nn(e, t, i) {
  if (!e.content)
    return;
  const r = t.messages[t.messages.length - 1];
  (r == null ? void 0 : r.role) === "assistant" && !r.interrupted && (r.interrupted = !0);
  const o = {
    id: e.id || `user-${Date.now()}`,
    role: e.role,
    content: e.content,
    created_at: e.created_at || (/* @__PURE__ */ new Date()).toISOString(),
    transcribed: !0
  };
  t.messages.push(o), i == null || i([...t.messages], "user");
}
function rn(e, t, i, r, o) {
  if (e === X.Transcribe && t.content) {
    nn(t, r, o);
    return;
  }
  if (!(e === X.Partial || e === X.Answer))
    return;
  const a = r.messages[r.messages.length - 1];
  let s;
  if (a != null && a.transcribed && a.role === "user")
    e === X.Answer && t.content, s = {
      id: t.id || `assistant-${Date.now()}`,
      role: t.role || "assistant",
      content: t.content || "",
      created_at: t.created_at || (/* @__PURE__ */ new Date()).toISOString()
    }, r.messages.push(s);
  else if ((a == null ? void 0 : a.role) === "assistant")
    s = a;
  else
    return;
  const { content: d, sequence: n } = t;
  e === X.Partial ? i[n] = d : i.answer = d;
  const c = tn(i);
  (s.content !== c || e === X.Answer) && (s.content = c, o == null || o([...r.messages], e));
}
function an(e, t, i, r, o) {
  let a = {};
  const s = () => a = {};
  let d = "answer";
  const n = (c, w) => {
    var y, g;
    w === "user" && s(), d = w, (g = (y = i.callbacks).onNewMessage) == null || g.call(y, c, w);
  };
  return {
    clearQueue: s,
    onMessage: (c, w) => {
      var y, g;
      if ("content" in w) {
        const f = c === A.ChatAnswer ? X.Answer : c === A.ChatAudioTranscribed ? X.Transcribe : c;
        rn(f, w, a, t, n), f === X.Answer && e.track("agent-message-received", {
          messages: t.messages.length,
          mode: t.chatMode
        });
      } else {
        const f = A, L = [f.StreamVideoDone, f.StreamVideoError, f.StreamVideoRejected], J = [f.StreamFailed, f.StreamVideoError, f.StreamVideoRejected], D = Pt(w, r, { mode: t.chatMode });
        if (c = c, c === f.StreamVideoCreated && (e.linkTrack("agent-video", D, f.StreamVideoCreated, ["start"]), w.sentiment)) {
          const k = t.messages[t.messages.length - 1];
          if ((k == null ? void 0 : k.role) === "assistant") {
            const P = { ...k, sentiment: w.sentiment };
            t.messages[t.messages.length - 1] = P, n == null || n([...t.messages], d);
          }
        }
        if (L.includes(c)) {
          const k = c.split("/")[1];
          J.includes(c) ? e.track("agent-video", { ...D, event: k }) : e.linkTrack("agent-video", { ...D, event: k }, c, ["done"]);
        }
        J.includes(c) && ((g = (y = i.callbacks).onError) == null || g.call(y, new Error(`Stream failed with event ${c}`), { data: w })), w.event === f.StreamDone && o();
      }
    }
  };
}
function on(e, t, i, r) {
  const o = Le(e, `${t}/agents/${i}`, r);
  return {
    createStream(a, s) {
      return o.post("/streams", a, { signal: s });
    },
    startConnection(a, s, d, n) {
      return o.post(
        `/streams/${a}/sdp`,
        {
          session_id: d,
          answer: s
        },
        { signal: n }
      );
    },
    addIceCandidate(a, s, d, n) {
      return o.post(
        `/streams/${a}/ice`,
        {
          session_id: d,
          ...s
        },
        { signal: n }
      );
    },
    sendStreamRequest(a, s, d) {
      return o.post(`/streams/${a}`, {
        session_id: s,
        ...d
      });
    },
    close(a, s) {
      return o.delete(`/streams/${a}`, { session_id: s });
    }
  };
}
const sn = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function Ve(e) {
  switch (e) {
    case "connected":
      return T.Connected;
    case "checking":
      return T.Connecting;
    case "failed":
      return T.Fail;
    case "new":
      return T.New;
    case "closed":
      return T.Closed;
    case "disconnected":
      return T.Disconnected;
    case "completed":
      return T.Completed;
    default:
      return T.New;
  }
}
const cn = (e) => (t) => {
  const [i, r = ""] = t.split(/:(.+)/);
  try {
    const o = JSON.parse(r);
    return e("parsed data channel message", { subject: i, data: o }), { subject: i, data: o };
  } catch (o) {
    return e("Failed to parse data channel message, returning data as string", { subject: i, rawData: r, error: o }), { subject: i, data: r };
  }
};
function dn({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: i,
  report: r,
  log: o
}) {
  e === S.Start && t === S.Start ? (o("CALLBACK: onVideoStateChange(Start)"), i == null || i(S.Start)) : e === S.Stop && t === S.Stop && (o("CALLBACK: onVideoStateChange(Stop)"), i == null || i(S.Stop, r));
}
function un({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: i,
  onAgentActivityStateChange: r,
  report: o,
  log: a
}) {
  e === S.Start ? (a("CALLBACK: onVideoStateChange(Start)"), i == null || i(S.Start)) : e === S.Stop && (a("CALLBACK: onVideoStateChange(Stop)"), i == null || i(S.Stop, o)), t === S.Start ? r == null || r(O.Talking) : t === S.Stop && (r == null || r(O.Idle));
}
function Je({
  statsSignal: e,
  dataChannelSignal: t,
  onVideoStateChange: i,
  onAgentActivityStateChange: r,
  streamType: o,
  report: a,
  log: s
}) {
  o === re.Legacy ? dn({ statsSignal: e, dataChannelSignal: t, onVideoStateChange: i, report: a, log: s }) : o === re.Fluent && un({
    statsSignal: e,
    dataChannelSignal: t,
    onVideoStateChange: i,
    onAgentActivityStateChange: r,
    report: a,
    log: s
  });
}
async function ln(e, t, { debug: i = !1, callbacks: r, auth: o, baseURL: a = pe, analytics: s }, d) {
  var ie;
  const n = Ge(i, "WebRTCStreamingManager"), c = cn(n);
  let w = !1, y = !1, g = S.Stop, f = S.Stop;
  const { startConnection: L, sendStreamRequest: J, close: D, createStream: k, addIceCandidate: P } = on(
    o,
    a,
    e,
    r.onError
  ), {
    id: I,
    offer: F,
    ice_servers: $,
    session_id: H,
    fluent: Z,
    interrupt_enabled: se,
    triggers_enabled: N
  } = await k(t, d);
  (ie = r.onStreamCreated) == null || ie.call(r, { stream_id: I, session_id: H, agent_id: e });
  const u = new sn({ iceServers: $ }), C = u.createDataChannel("JanusDataChannel");
  if (!H)
    throw new Error("Could not create session_id");
  const R = Z ? re.Fluent : re.Legacy;
  s.enrich({
    "stream-type": R
  });
  const z = t.stream_warmup && !Z, b = () => w, _ = () => {
    var p;
    w = !0, y && (n("CALLBACK: onConnectionStateChange(Connected)"), (p = r.onConnectionStateChange) == null || p.call(r, T.Connected));
  }, K = Ze(
    () => u.getStats(),
    b,
    _,
    (p, m) => Je({
      statsSignal: f = p,
      dataChannelSignal: R === re.Legacy ? g : void 0,
      onVideoStateChange: r.onVideoStateChange,
      onAgentActivityStateChange: r.onAgentActivityStateChange,
      report: m,
      streamType: R,
      log: n
    }),
    (p) => {
      var m;
      return (m = r.onConnectivityStateChange) == null ? void 0 : m.call(r, p);
    }
  );
  K.start(), u.onicecandidate = (p) => {
    var m;
    n("peerConnection.onicecandidate", p);
    try {
      p.candidate && p.candidate.sdpMid && p.candidate.sdpMLineIndex !== null ? P(
        I,
        {
          candidate: p.candidate.candidate,
          sdpMid: p.candidate.sdpMid,
          sdpMLineIndex: p.candidate.sdpMLineIndex
        },
        H,
        d
      ) : P(I, { candidate: null }, H, d);
    } catch (M) {
      (m = r.onError) == null || m.call(r, M, { streamId: I });
    }
  }, C.onopen = () => {
    y = !0, (!z || w) && _();
  };
  const q = (p) => {
    var m;
    (m = r.onVideoIdChange) == null || m.call(r, p);
  };
  function W(p, m) {
    if (p === A.StreamStarted && typeof m == "object" && "metadata" in m) {
      const M = m.metadata;
      q(M.videoId);
    }
    p === A.StreamDone && q(null), g = p === A.StreamStarted ? S.Start : S.Stop, Je({
      statsSignal: R === re.Legacy ? f : void 0,
      dataChannelSignal: g,
      onVideoStateChange: r.onVideoStateChange,
      onAgentActivityStateChange: r.onAgentActivityStateChange,
      streamType: R,
      log: n
    });
  }
  function j(p, m) {
    var G;
    const M = typeof m == "string" ? m : m == null ? void 0 : m.metadata;
    M && s.enrich({ streamMetadata: M }), (G = r.onStreamReady) == null || G.call(r);
  }
  const B = {
    [A.StreamStarted]: W,
    [A.StreamDone]: W,
    [A.StreamReady]: j
  };
  C.onmessage = (p) => {
    var G;
    const { subject: m, data: M } = c(p.data);
    (G = B[m]) == null || G.call(B, m, M);
  }, u.oniceconnectionstatechange = () => {
    var m;
    n("peerConnection.oniceconnectionstatechange => " + u.iceConnectionState);
    const p = Ve(u.iceConnectionState);
    p !== T.Connected && ((m = r.onConnectionStateChange) == null || m.call(r, p));
  }, u.ontrack = (p) => {
    var m;
    n("peerConnection.ontrack", p), n("CALLBACK: onSrcObjectReady"), (m = r.onSrcObjectReady) == null || m.call(r, p.streams[0]);
  }, await u.setRemoteDescription(F), n("set remote description OK");
  const Y = await u.createAnswer();
  return n("create answer OK"), await u.setLocalDescription(Y), n("set local description OK"), await L(I, Y, H, d), n("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(p) {
      return J(I, H, p);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var p;
      if (I) {
        const m = Ve(u.iceConnectionState);
        if (u) {
          if (m === T.New) {
            K.stop();
            return;
          }
          u.close(), u.oniceconnectionstatechange = null, u.onnegotiationneeded = null, u.onicecandidate = null, u.ontrack = null;
        }
        try {
          m === T.Connected && await D(I, H).catch((M) => {
          });
        } catch (M) {
          n("Error on close stream connection", M);
        }
        (p = r.onAgentActivityStateChange) == null || p.call(r, O.Idle), K.stop();
      }
    },
    /**
     * Method to send data channel messages to the server
     */
    sendDataChannelMessage(p) {
      var m, M;
      if (!w || C.readyState !== "open") {
        n("Data channel is not ready for sending messages"), (m = r.onError) == null || m.call(r, new Error("Data channel is not ready for sending messages"), {
          streamId: I
        });
        return;
      }
      try {
        C.send(p);
      } catch (G) {
        n("Error sending data channel message", G), (M = r.onError) == null || M.call(r, G, { streamId: I });
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: H,
    /**
     * Id of current RTC stream
     */
    streamId: I,
    streamType: R,
    interruptAvailable: se ?? !1,
    triggersAvailable: N ?? !1
  };
}
var _e = /* @__PURE__ */ ((e) => (e.V1 = "v1", e.V2 = "v2", e))(_e || {});
async function fn(e, t, i, r) {
  const o = e.id;
  switch (t.version) {
    case "v1": {
      const { version: a, ...s } = t;
      return ln(o, s, i, r);
    }
    case "v2": {
      const { version: a, ...s } = t;
      switch (s.transport_provider) {
        case ke.Livekit:
          const { createLiveKitStreamingManager: d } = await Promise.resolve().then(() => qt);
          return d(o, s, i);
        default:
          throw new Error(`Unsupported transport provider: ${s.transport_provider}`);
      }
    }
    default:
      throw new Error(`Invalid stream version: ${t.version}`);
  }
}
const mn = "cht";
function gn() {
  return {
    transport_provider: ke.Livekit
  };
}
function hn(e) {
  var o, a;
  const { streamOptions: t } = e ?? {}, i = ((o = e == null ? void 0 : e.mixpanelAdditionalProperties) == null ? void 0 : o.plan) !== void 0 ? {
    plan: (a = e.mixpanelAdditionalProperties) == null ? void 0 : a.plan
  } : void 0;
  return { ...{
    output_resolution: t == null ? void 0 : t.outputResolution,
    session_timeout: t == null ? void 0 : t.sessionTimeout,
    stream_warmup: t == null ? void 0 : t.streamWarmup,
    compatibility_mode: t == null ? void 0 : t.compatibilityMode,
    fluent: t == null ? void 0 : t.fluent
  }, ...i && { end_user_data: i } };
}
function pn(e, t) {
  return Ae(e.presenter.type) ? { version: _e.V2, ...gn() } : { version: _e.V1, ...hn(t) };
}
function wn(e, t, i) {
  i.track("agent-connection-state-change", { state: e, ...t && { reason: t } });
}
function yn(e, t, i, r, o) {
  o === re.Fluent ? vn(e, t, i, r, o) : Cn(e, t, i, r, o);
}
function vn(e, t, i, r, o) {
  e === S.Start ? r.track("stream-session", { event: "start", "stream-type": o }) : e === S.Stop && r.track("stream-session", {
    event: "stop",
    is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
    background: t.presenter.type === "clip" && t.presenter.background,
    "stream-type": o,
    ...i
  });
}
function Sn(e, t, i, r) {
  ee.get() <= 0 || (e === S.Start ? i.linkTrack(
    "agent-video",
    { event: "start", latency: ee.get(!0), "stream-type": r },
    "start",
    [A.StreamVideoCreated]
  ) : e === S.Stop && i.linkTrack(
    "agent-video",
    {
      event: "stop",
      is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
      background: t.presenter.type === "clip" && t.presenter.background,
      "stream-type": r
    },
    "done",
    [A.StreamVideoDone]
  ));
}
function Cn(e, t, i, r, o) {
  ee.get() <= 0 || (e === S.Start ? r.linkTrack(
    "agent-video",
    { event: "start", latency: ee.get(!0), "stream-type": o },
    "start",
    [A.StreamVideoCreated]
  ) : e === S.Stop && r.linkTrack(
    "agent-video",
    {
      event: "stop",
      is_greenscreen: t.presenter.type === "clip" && t.presenter.is_greenscreen,
      background: t.presenter.type === "clip" && t.presenter.background,
      "stream-type": o,
      ...i
    },
    "done",
    [A.StreamVideoDone]
  ));
}
function Ue(e, t, i, r) {
  return ee.reset(), Ke.update(), new Promise(async (o, a) => {
    try {
      let s, d = !1;
      const n = pn(e, t);
      i.enrich({
        "stream-version": n.version.toString()
      }), s = await fn(
        e,
        n,
        {
          ...t,
          analytics: i,
          callbacks: {
            ...t.callbacks,
            onConnectionStateChange: (c, w) => {
              var y, g;
              (g = (y = t.callbacks).onConnectionStateChange) == null || g.call(y, c), wn(c, w, i), c === T.Connected && (s ? o(s) : d = !0);
            },
            onVideoStateChange: (c, w) => {
              var y, g;
              (g = (y = t.callbacks).onVideoStateChange) == null || g.call(y, c), yn(
                c,
                e,
                w,
                i,
                s.streamType
              );
            },
            onAgentActivityStateChange: (c) => {
              var w, y;
              (y = (w = t.callbacks).onAgentActivityStateChange) == null || y.call(w, c), c === O.Talking ? Ie.update() : Ie.reset(), Sn(
                c === O.Talking ? S.Start : S.Stop,
                e,
                i,
                s.streamType
              );
            },
            onStreamReady: () => {
              const c = Ke.get(!0);
              i.track("agent-chat", { event: "ready", latency: c });
            }
          }
        },
        r
      ), d && o(s);
    } catch (s) {
      a(s);
    }
  });
}
async function kn(e, t, i, r, o) {
  var w, y, g, f;
  const a = async () => {
    if (Ae(e.presenter.type)) {
      const L = await Ue(e, t, r), J = `${mn}_${L.sessionId}`, D = (/* @__PURE__ */ new Date()).toISOString();
      return { chatResult: {
        chatMode: x.Functional,
        chat: {
          id: J,
          agent_id: e.id,
          owner_id: e.owner_id ?? "",
          created: D,
          modified: D,
          agent_id__created_at: D,
          agent_id__modified_at: D,
          chat_mode: x.Functional,
          messages: []
        }
      }, streamingManager: L };
    } else {
      const L = new AbortController(), J = L.signal;
      let D;
      try {
        const k = Ye(
          e,
          i,
          r,
          t.mode,
          t.persistentChat,
          o
        ), P = Ue(e, t, r, J).then(($) => (D = $, $)), [I, F] = await Promise.all([k, P]);
        return { chatResult: I, streamingManager: F };
      } catch (k) {
        throw L.abort(), D && await D.disconnect().catch(() => {
        }), k;
      }
    }
  }, { chatResult: s, streamingManager: d } = await a(), { chat: n, chatMode: c } = s;
  return c && t.mode !== void 0 && c !== t.mode && (t.mode = c, (y = (w = t.callbacks).onModeChange) == null || y.call(w, c), c !== x.Functional) ? ((f = (g = t.callbacks).onError) == null || f.call(g, new ct(c)), d == null || d.disconnect(), { chat: n }) : { chat: n, streamingManager: d };
}
async function Mn(e, t) {
  var H, Z, se, N;
  let i = !0, r = null;
  const o = t.mixpanelKey || kt, a = t.wsURL || Ct, s = t.baseURL || pe, d = t.mode || x.Functional, n = {
    messages: [],
    chatMode: d
  }, c = jt({
    token: o,
    agentId: e,
    isEnabled: t.enableAnalitics,
    externalId: t.externalId,
    mixpanelAdditionalProperties: t.mixpanelAdditionalProperties
  }), w = Date.now();
  ze(() => {
    c.track("agent-sdk", { event: "init" }, w);
  });
  const y = Tt(t.auth, s, t.callbacks.onError, t.externalId), g = await y.getById(e);
  t.debug = t.debug || ((H = g == null ? void 0 : g.advanced_settings) == null ? void 0 : H.ui_debug_mode);
  const f = Ae(g.presenter.type);
  c.enrich(At(g));
  const { onMessage: L, clearQueue: J } = an(
    c,
    n,
    t,
    g,
    () => {
      var u;
      return (u = n.socketManager) == null ? void 0 : u.disconnect();
    }
  );
  n.messages = Bt(t.initialMessages), (se = (Z = t.callbacks).onNewMessage) == null || se.call(Z, [...n.messages], "answer");
  const D = (u) => {
    r = u;
  }, k = ({ type: u }) => {
    var R, z, b;
    const C = n.messages[n.messages.length - 1];
    c.track("agent-video-interrupt", {
      type: u || "click",
      video_duration_to_interrupt: Ie.get(!0),
      message_duration_to_interrupt: ee.get(!0)
    }), C.interrupted = !0, (z = (R = t.callbacks).onNewMessage) == null || z.call(R, [...n.messages], "answer"), f ? Yt(n.streamingManager) : (Qt(n.streamingManager, (b = n.streamingManager) == null ? void 0 : b.streamType, r), Xt(n.streamingManager, r));
  }, P = Date.now();
  ze(() => {
    c.track("agent-sdk", { event: "loaded", ..._t(g) }, P);
  });
  async function I(u) {
    var K, q, W, j, B, Y, ie;
    (q = (K = t.callbacks).onConnectionStateChange) == null || q.call(K, T.Connecting), ee.reset(), u && !i && (delete n.chat, (j = (W = t.callbacks).onNewMessage) == null || j.call(W, [...n.messages], "answer"));
    const C = d === x.DirectPlayback || f ? Promise.resolve(void 0) : en(
      t.auth,
      a,
      { onMessage: L, onError: t.callbacks.onError },
      t.externalId
    ), R = Me(
      () => kn(
        g,
        {
          ...t,
          mode: d,
          callbacks: {
            ...t.callbacks,
            onVideoIdChange: D,
            onMessage: L,
            onInterruptDetected: k
          }
        },
        y,
        c,
        n.chat
      ),
      {
        limit: 3,
        timeout: vt,
        timeoutErrorMessage: "Timeout initializing the stream",
        shouldRetryFn: (p) => (p == null ? void 0 : p.message) !== "Could not connect" && p.status !== 429 && (p == null ? void 0 : p.message) !== "InsufficientCreditsError",
        delayMs: 1e3
      }
    ).catch((p) => {
      var m, M;
      throw $(x.Maintenance), (M = (m = t.callbacks).onConnectionStateChange) == null || M.call(m, T.Fail), p;
    }), [z, { streamingManager: b, chat: _ }] = await Promise.all([C, R]);
    _ && _.id !== ((B = n.chat) == null ? void 0 : B.id) && ((ie = (Y = t.callbacks).onNewChat) == null || ie.call(Y, _.id)), n.streamingManager = b, n.socketManager = z, n.chat = _, i = !1, c.enrich({
      chatId: _ == null ? void 0 : _.id,
      streamId: b == null ? void 0 : b.streamId,
      mode: n.chatMode
    }), $((_ == null ? void 0 : _.chat_mode) ?? d);
  }
  async function F() {
    var u, C, R, z;
    (u = n.socketManager) == null || u.disconnect(), await ((C = n.streamingManager) == null ? void 0 : C.disconnect()), delete n.streamingManager, delete n.socketManager, (z = (R = t.callbacks).onConnectionStateChange) == null || z.call(R, T.Disconnected);
  }
  async function $(u) {
    var C, R;
    u !== n.chatMode && (c.track("agent-mode-change", { mode: u }), n.chatMode = u, n.chatMode !== x.Functional && await F(), (R = (C = t.callbacks).onModeChange) == null || R.call(C, u));
  }
  return {
    agent: g,
    getStreamType: () => {
      var u;
      return (u = n.streamingManager) == null ? void 0 : u.streamType;
    },
    getIsInterruptAvailable: () => {
      var u;
      return ((u = n.streamingManager) == null ? void 0 : u.interruptAvailable) ?? !1;
    },
    getIsTriggersAvailable: () => {
      var u;
      return ((u = n.streamingManager) == null ? void 0 : u.triggersAvailable) ?? !1;
    },
    starterMessages: ((N = g.knowledge) == null ? void 0 : N.starter_message) || [],
    getSTTToken: () => y.getSTTToken(g.id),
    changeMode: $,
    enrichAnalytics: c.enrich,
    async connect() {
      await I(!0), c.track("agent-chat", {
        event: "connect",
        mode: n.chatMode
      });
    },
    async reconnect() {
      const u = n.streamingManager;
      if (f && (u != null && u.reconnect)) {
        try {
          await u.reconnect(), c.track("agent-chat", {
            event: "reconnect",
            mode: n.chatMode
          });
        } catch {
          await F(), await I(!1);
        }
        return;
      }
      await F(), await I(!1), c.track("agent-chat", {
        event: "reconnect",
        mode: n.chatMode
      });
    },
    async disconnect() {
      await F(), c.track("agent-chat", {
        event: "disconnect",
        mode: n.chatMode
      });
    },
    async publishMicrophoneStream(u) {
      var C;
      if (!((C = n.streamingManager) != null && C.publishMicrophoneStream))
        throw new Error("publishMicrophoneStream is not available for this streaming manager");
      return n.streamingManager.publishMicrophoneStream(u);
    },
    async unpublishMicrophoneStream() {
      var u;
      if (!((u = n.streamingManager) != null && u.unpublishMicrophoneStream))
        throw new Error("unpublishMicrophoneStream is not available for this streaming manager");
      return n.streamingManager.unpublishMicrophoneStream();
    },
    async chat(u) {
      var b, _, K, q, W;
      const C = () => {
        if (qe(d))
          throw new fe(`${d} is enabled, chat is disabled`);
        if (u.length >= 800)
          throw new fe("Message cannot be more than 800 characters");
        if (u.length === 0)
          throw new fe("Message cannot be empty");
        if (n.chatMode === x.Maintenance)
          throw new fe("Chat is in maintenance mode");
        if (![x.TextOnly, x.Playground].includes(n.chatMode)) {
          if (!n.streamingManager)
            throw new fe("Streaming manager is not initialized");
          if (!n.chat)
            throw new fe("Chat is not initialized");
        }
      }, R = async () => {
        var j, B;
        if (!n.chat) {
          const Y = await Ye(
            g,
            y,
            c,
            n.chatMode,
            t.persistentChat
          );
          if (!Y.chat)
            throw new st(n.chatMode, !!t.persistentChat);
          n.chat = Y.chat, (B = (j = t.callbacks).onNewChat) == null || B.call(j, n.chat.id);
        }
        return n.chat.id;
      }, z = async (j, B) => {
        const Y = n.chatMode === x.Playground;
        return Me(f && !Y ? async () => {
          var m, M;
          return await ((M = (m = n.streamingManager) == null ? void 0 : m.sendTextMessage) == null ? void 0 : M.call(m, u)), Promise.resolve({});
        } : async () => {
          var m, M;
          return y.chat(
            g.id,
            B,
            {
              chatMode: n.chatMode,
              streamId: (m = n.streamingManager) == null ? void 0 : m.streamId,
              sessionId: (M = n.streamingManager) == null ? void 0 : M.sessionId,
              messages: j.map(({ matches: G, ...ce }) => ce)
            },
            {
              ...Xe(n.chatMode),
              skipErrorHandler: !0
            }
          );
        }, {
          limit: 2,
          shouldRetryFn: (m) => {
            var ce, de, we, ue;
            const M = (ce = m == null ? void 0 : m.message) == null ? void 0 : ce.includes("missing or invalid session_id");
            return !((de = m == null ? void 0 : m.message) == null ? void 0 : de.includes("Stream Error")) && !M ? ((ue = (we = t.callbacks).onError) == null || ue.call(we, m), !1) : !0;
          },
          onRetry: async () => {
            await F(), await I(!1);
          }
        });
      };
      try {
        J(), C(), n.messages.push({
          id: me(),
          role: "user",
          content: u,
          created_at: new Date(ee.update()).toISOString()
        }), (_ = (b = t.callbacks).onNewMessage) == null || _.call(b, [...n.messages], "user");
        const j = await R(), B = await z([...n.messages], j);
        return n.messages.push({
          id: me(),
          role: "assistant",
          content: B.result || "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          context: B.context,
          matches: B.matches
        }), c.track("agent-message-send", {
          event: "success",
          messages: n.messages.length + 1
        }), B.result && ((q = (K = t.callbacks).onNewMessage) == null || q.call(K, [...n.messages], "answer"), c.track("agent-message-received", {
          latency: ee.get(!0),
          messages: n.messages.length
        })), B;
      } catch (j) {
        throw ((W = n.messages[n.messages.length - 1]) == null ? void 0 : W.role) === "assistant" && n.messages.pop(), c.track("agent-message-send", {
          event: "error",
          messages: n.messages.length
        }), j;
      }
    },
    rate(u, C, R) {
      var _, K, q, W;
      const z = n.messages.find((j) => j.id === u);
      if (n.chat) {
        if (!z)
          throw new Error("Message not found");
      } else throw new Error("Chat is not initialized");
      const b = ((_ = z.matches) == null ? void 0 : _.map((j) => [j.document_id, j.id])) ?? [];
      return c.track("agent-rate", {
        event: R ? "update" : "create",
        thumb: C === 1 ? "up" : "down",
        knowledge_id: ((K = g.knowledge) == null ? void 0 : K.id) ?? "",
        matches: b,
        score: C
      }), R ? y.updateRating(g.id, n.chat.id, R, {
        knowledge_id: ((q = g.knowledge) == null ? void 0 : q.id) ?? "",
        message_id: u,
        matches: b,
        score: C
      }) : y.createRating(g.id, n.chat.id, {
        knowledge_id: ((W = g.knowledge) == null ? void 0 : W.id) ?? "",
        message_id: u,
        matches: b,
        score: C
      });
    },
    deleteRate(u) {
      if (!n.chat)
        throw new Error("Chat is not initialized");
      return c.track("agent-rate-delete", { type: "text" }), y.deleteRating(g.id, n.chat.id, u);
    },
    async speak(u) {
      var b, _, K;
      function C() {
        if (typeof u == "string") {
          if (!g.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: g.presenter.voice,
            input: u,
            ssml: !1
          };
        }
        if (u.type === "text" && !u.provider) {
          if (!g.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: g.presenter.voice,
            input: u.input,
            ssml: u.ssml
          };
        }
        return u;
      }
      const R = C();
      if (c.track("agent-speak", R), ee.update(), n.messages && R.type === "text" && (n.messages.push({
        id: me(),
        role: "assistant",
        content: R.input,
        created_at: (/* @__PURE__ */ new Date()).toISOString()
      }), (_ = (b = t.callbacks).onNewMessage) == null || _.call(b, [...n.messages], "answer")), Dt(n.chatMode))
        return {
          duration: 0,
          video_id: "",
          status: "success"
        };
      if (!n.streamingManager)
        throw new Error("Please connect to the agent first");
      return n.streamingManager.speak({
        script: R,
        metadata: { chat_id: (K = n.chat) == null ? void 0 : K.id, agent_id: g.id }
      });
    },
    interrupt: k
  };
}
export {
  O as AgentActivityState,
  ft as AgentStatus,
  st as ChatCreationFailed,
  x as ChatMode,
  ct as ChatModeDowngraded,
  X as ChatProgress,
  T as ConnectionState,
  ne as ConnectivityState,
  pt as DocumentType,
  ht as KnowledgeType,
  lt as PlanGroup,
  wt as Providers,
  mt as RateState,
  A as StreamEvents,
  re as StreamType,
  S as StreamingState,
  gt as Subject,
  ke as TransportProvider,
  ut as UserPlan,
  fe as ValidationError,
  We as VideoType,
  yt as VoiceAccess,
  dt as WsError,
  Mn as createAgentManager,
  Dn as mapVideoType
};
